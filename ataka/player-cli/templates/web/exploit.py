#!/usr/bin/env python3

import os
import sys
import json
import pickle
import random
import string
import functools
import traceback
import threading
import requests

from collections import OrderedDict
from time import sleep


def gen_random_str(n=10, charset=string.ascii_letters + string.digits):
    """Get a random string of length n from the provided charset.
    Example:

    >>> gen_random_str(random.randint(7, 18), string.ascii_uppercase + string.digits)
    '9T9UINWLBTDNUS2'
    """

    return ''.join(random.choice(charset) for _ in range(n))


def exploit(host, flagid=None):
    # this stuff sleeps 0-1 seconds between requests
    def sleep_between_requests(response, *args, **kwargs):
        sleep(random.uniform(0, 1))

    """Attack a single team and print flags. No need to print only flags here, output can be messy."""

    url = f'http://{host}:1234'
    
    s = requests.Session()

    # if you want to disable keepalive to make network traffic analysis more difficult
    # set the User-Agent to simulate the checker
    s.headers.update({'Connection': 'close', 'User-Agent': 'python-requests/2.32.5'})

    # uncomment if you want to sleep 0-1s between requests to make traffic detection harder
    # s.hooks['response'].append(sleep_between_requests)

    # uncomment if you want a global timeout on all requests (https://github.com/psf/requests/issues/2011#issuecomment-490050252)
    # s.request = functools.partial(s.request, timeout=5)

    username = gen_random_str(8)
    password = gen_random_str(10)

    r = s.post(f'{url}/login.php', data={'username': username, 'password': password}, timeout=3) # log-in
    r = s.get(f'{url}/index.php', timeout=3) # session established, now do something
    
    print(r.text)

HOST = os.getenv('TARGET_IP')
EXTRA = json.loads(os.getenv('TARGET_EXTRA', '[]'))

# execute the exploit on all provided flagids
if len(EXTRA) > 0:
    for flagid in EXTRA:
        try:
            exploit(HOST, flagid)
        except Exception as e: 
            traceback.print_exc()
            print(f'Error: {e}', file=sys.stderr, flush=True)
# or execute the exploit directly without flagids
else:
    exploit(HOST)
